/**
 * Stability Scorer for Selector Candidates
 *
 * Calculates how resistant a selector is to UI changes.
 * Higher scores mean the selector is less likely to break
 * when the page structure or styling changes.
 */

import type { SelectorCandidate } from '@like-cake/ast-types';

/**
 * Base stability scores for each selector strategy
 * Based on how each strategy type typically responds to UI changes
 */
const STRATEGY_STABILITY_SCORES: Record<string, number> = {
  testId: 95, // data-testid is explicitly for testing, rarely changes
  ariaLabel: 85, // Accessibility attributes are intentional, fairly stable
  role: 80, // ARIA roles are semantic, moderately stable
  text: 70, // Text content can change with i18n or copy updates
  id: 65, // IDs can be dynamic (generated by frameworks)
  name: 60, // Form names are moderately stable
  class: 40, // Classes change frequently with styling updates
  css: 30, // Generic CSS paths are fragile
  xpath: 20, // Structure-dependent, breaks with layout changes
};

/**
 * Calculate stability score for a selector candidate
 *
 * @returns Score from 0-100 where higher means more stable
 */
export function calculateStabilityScore(candidate: SelectorCandidate): number {
  let score = STRATEGY_STABILITY_SCORES[candidate.strategy] || 0;

  // Bonus for unique selectors (less likely to match wrong element)
  if (candidate.isUnique) score += 5;

  // Bonus for readable selectors (easier to maintain)
  if (candidate.isReadable) score += 5;

  // Penalty for positional selectors (break when siblings change)
  if (candidate.selector.includes(':nth-child')) score -= 20;
  if (candidate.selector.includes(':nth-of-type')) score -= 15;

  // Penalty for deeply chained selectors (break when structure changes)
  const chainDepth = candidate.selector.split('>').length;
  if (chainDepth > 3) score -= 15;
  if (chainDepth > 5) score -= 10; // additional penalty for very deep chains

  // Penalty for selectors that rely on class combinations
  const classCount = (candidate.selector.match(/\./g) || []).length;
  if (classCount > 2) score -= 10;

  return Math.max(0, Math.min(100, score));
}

/**
 * Sort candidates by stability score (highest first)
 */
export function rankByStability(candidates: SelectorCandidate[]): SelectorCandidate[] {
  return [...candidates].sort((a, b) => {
    const scoreA = calculateStabilityScore(a);
    const scoreB = calculateStabilityScore(b);
    return scoreB - scoreA;
  });
}
